@page
@model FTdx101_WebApp.Pages.IndexModel
@{
    ViewData["Title"] = "FT-dx101 Series Control";
}

<!-- Cache-busted CSS reference -->
<link rel="stylesheet" href="~/css/site.css?v=20260214" />

<!-- Overlay for initialization status -->
<div id="initOverlay" class="init-overlay">
    <div class="init-message">
        <span id="initStatusText">Initializing radio, please wait...</span>
        <div class="spinner-border text-primary" role="status"></div>
    </div>
</div>

<div class="container-fluid">
    <div class="row g-3 flex-wrap">
        <!-- Receiver A Panel -->
        <div class="col-lg-6 col-12">
            <div class="card border-primary h-100 receiver-card">
                <div class="card-header bg-primary text-white">
                    <h3>
                        <span id="receiverAHeading">Receiver A</span>
                    </h3>
                </div>
                <div class="card-body">
                    <!-- S-Meter at top -->
                    <div class="mb-3">
                        <label>S-Meter:</label>
                        <div class="analog-meter-container">
                            <canvas id="sMeterCanvasA"></canvas>
                        </div>
                        <div class="text-center mt-1">
                            <span id="sMeterValueA" class="badge bg-secondary">S0</span>
                            <span id="sMeterRawA" class="text-muted ms-2 small">[0]</span>
                        </div>
                    </div>

                    <!-- Controls below -->
                    <div>
                        <label>Frequency:</label>
                        <div class="d-flex align-items-center">
                            <span id="freqA" class="fw-bold frequency-display digit-display"></span>
                            <div id="freqA-controls" class="ms-2" style="display:none;">
                                <button id="freqA-up" class="btn btn-secondary btn-sm">▲</button>
                                <button id="freqA-down" class="btn btn-secondary btn-sm">▼</button>
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label>Bands (A):</label>
                        @await Html.PartialAsync("_BandButtonsPartial", Tuple.Create("unused", "A", Model.SelectedBandA))
                    </div>
                    <!-- POWER CONTROL FOR RECEIVER A -->
                    <div class="mb-3">
                        <label>Power: <span id="powerValueA" class="fw-bold">0W</span></label>
                        <input type="range" class="form-range power-slider"
                               id="powerSliderA"
                               min="5"
                               max="200"
                               step="5"
                               value="100"
                               oninput="window.radioControl.updatePowerDisplay('A', this.value)"
                               onchange="window.radioControl.setPower('A', this.value)">
                        <div class="d-flex justify-content-between small text-muted">
                            <span>5W</span>
                            <span>100W</span>
                            <span id="powerMaxLabelA">@Model.RadioState.MaxPower W</span>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label>Mode:</label>
                        <div class="d-flex flex-wrap gap-2">
                            @foreach (var mode in new[] { "LSB", "USB", "CW", "FM", "DATA-USB", "RTTY-USB" })
                            {
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input"
                                           type="radio"
                                           name="modeA"
                                           id="modeA_@mode"
                                           value="@mode"
                                           @(Model.RadioState.ModeA == mode ? "checked" : "")
                                           onchange="window.radioControl.setMode('A','@mode')">
                                    <label class="form-check-label" for="modeA_@mode">@mode</label>
                                </div>
                            }
                        </div>
                    </div>
                    <div class="mb-3">
                        <label>Antenna:</label>
                        <div class="d-flex flex-wrap gap-2">
                            @foreach (var ant in new[] { "1", "2", "3" })
                            {
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input"
                                           type="radio"
                                           name="antennaA"
                                           id="antennaA_@ant"
                                           value="@ant"
                                           @(Model.RadioState.AntennaA == ant ? "checked" : "")
                                           onchange="window.radioControl.setAntenna('A','@ant')">
                                    <label class="form-check-label" for="antennaA_@ant">ANT @ant</label>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Receiver B Panel -->
        <div class="col-lg-6 col-12">
            <div class="card border-success h-100 receiver-card">
                <div class="card-header bg-success text-white">
                    <h3>
                        <span id="receiverBHeading">Receiver B</span>
                    </h3>
                </div>
                <div class="card-body">
                    <!-- S-Meter at top -->
                    <div class="mb-3">
                        <label>S-Meter:</label>
                        <div class="analog-meter-container">
                            <canvas id="sMeterCanvasB"></canvas>
                        </div>
                        <div class="text-center mt-1">
                            <span id="sMeterValueB" class="badge bg-secondary">S0</span>
                            <span id="sMeterRawB" class="text-muted ms-2 small">[0]</span>
                        </div>
                    </div>

                    <!-- Controls below -->
                    <div>
                        <label>Frequency:</label>
                        <div class="d-flex align-items-center">
                            <span id="freqB" class="fw-bold frequency-display digit-display"></span>
                            <div id="freqB-controls" class="ms-2" style="display:none;">
                                <button id="freqB-up" class="btn btn-secondary btn-sm">▲</button>
                                <button id="freqB-down" class="btn btn-secondary btn-sm">▼</button>
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label>Bands (B):</label>
                        @await Html.PartialAsync("_BandButtonsPartial", Tuple.Create("unused", "B", Model.SelectedBandB))
                    </div>
                    <!-- POWER CONTROL FOR RECEIVER B -->
                    
                    <div class="mb-3">
                        <label>Mode:</label>
                        <div class="d-flex flex-wrap gap-2">
                            @foreach (var mode in new[] { "LSB", "USB", "CW", "FM", "DATA-USB", "RTTY-USB" })
                            {
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input"
                                           type="radio"
                                           name="modeB"
                                           id="modeB_@mode"
                                           value="@mode"
                                           @(Model.RadioState.ModeB == mode ? "checked" : "")
                                           onchange="window.radioControl.setMode('B','@mode')">
                                    <label class="form-check-label" for="modeB_@mode">@mode</label>
                                </div>
                            }
                        </div>
                    </div>
                    <div class="mb-3">
                        <label>Antenna:</label>
                        <div class="d-flex flex-wrap gap-2">
                            @foreach (var ant in new[] { "1", "2", "3" })
                            {
                                <div class="form-check form-check-inline">
                                    <input class="form-check-input"
                                           type="radio"
                                           name="antennaB"
                                           id="antennaB_@ant"
                                           value="@ant"
                                           @(Model.RadioState.AntennaB == ant ? "checked" : "")
                                           onchange="window.radioControl.setAntenna('B','@ant')">
                                    <label class="form-check-label" for="antennaB_@ant">ANT @ant</label>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
@section Scripts {
    <!-- Cache-busted JS reference, placed BEFORE your inline script if you use window.radioControl, etc. -->
    <script src="~/js/site.js?v=20260214"></script>
    <script>
        (function() {
            'use strict';

            console.log('=== FTdx101 Control Interface Starting ===');

            // Gauge instances
            let gaugeA, gaugeB;

            const state = {
                editing: { A: false, B: false },
                editingPower: { A: false, B: false },
                localFreq: { A: null, B: null },
                selectedIdx: { A: null, B: null },
                lastSentFreq: { A: null, B: null },
                lastBackendFreq: { A: null, B: null },
                lastBand: { A: null, B: null },
                lastMode: { A: null, B: null },
                lastAntenna: { A: null, B: null },
                lastPower: { A: 100, B: 100 },
                maxPower: 200,
                radioModel: 'FTdx101MP',
                pollingInterval: null,
                operationInProgress: false
            };

            function renderFrequencyDigits(freq, selIdx) {
                if (!freq || freq < 1000) {
                    return '<span class="digit">-</span><span class="digit">-</span>.<span class="digit">-</span><span class="digit">-</span><span class="digit">-</span>.<span class="digit">-</span><span class="digit">-</span><span class="digit">-</span>';
                }
                let s = freq.toString().padStart(8, "0");
                let html = "";
                let digitIdx = 0;
                for (let i = 0; i < 8; i++) {
                    if (i === 2 || i === 5) {
                        html += '<span class="digit">.</span>';
                    }
                    let selected = (selIdx === digitIdx) ? " selected" : "";
                    html += `<span class="digit${selected}" tabindex="0">${s[i]}</span>`;
                    digitIdx++;
                }
                return html;
            }

            function updateFrequencyDisplay(receiver, freqHz) {
                const display = document.getElementById('freq' + receiver);
                if (!display) {
                    console.warn(`Frequency display element not found: freq${receiver}`);
                    return;
                }
                let selIdx = state.selectedIdx[receiver];
                let freqToShow = (state.editing[receiver] && state.localFreq[receiver] !== null) ? state.localFreq[receiver] : freqHz;
                display.innerHTML = renderFrequencyDigits(freqToShow, selIdx);
            }

            function highlightButtons(receiver, band, mode, antenna) {
                document.querySelectorAll(`.band-btn[data-receiver="${receiver}"]`).forEach(btn => {
                    btn.classList.toggle('active', btn.getAttribute('data-value') === band);
                });
                document.querySelectorAll(`.mode-btn[data-receiver="${receiver}"]`).forEach(btn => {
                    btn.classList.toggle('active', btn.getAttribute('data-value') === mode);
                });
                document.querySelectorAll(`.antenna-btn[data-receiver="${receiver}"]`).forEach(btn => {
                    btn.classList.toggle('active', btn.getAttribute('data-value') === antenna);
                });
            }

            function initializeDigitInteraction(receiver) {
                const display = document.getElementById('freq' + receiver);
                if (!display) {
                    console.warn(`Cannot initialize digit interaction: freq${receiver} not found`);
                    return;
                }
                if (display._initialized) return;
                display._initialized = true;

                display.addEventListener('click', function (e) {
                    if (!e.target.classList.contains('digit') || e.target.textContent === '.') return;
                    let digits = Array.from(display.querySelectorAll('.digit')).filter(d => d.textContent !== '.' );
                    digits.forEach(d => d.classList.remove('selected'));
                    state.selectedIdx[receiver] = digits.indexOf(e.target);
                    if (state.selectedIdx[receiver] !== -1) {
                        digits[state.selectedIdx[receiver]].classList.add('selected');
                        state.editing[receiver] = true;
                        state.localFreq[receiver] = parseInt(digits.map(d => d.textContent).join(''));
                    }
                });

                display.addEventListener('wheel', function (e) {
                    let digits = Array.from(display.querySelectorAll('.digit')).filter(d => d.textContent !== '.' );
                    let idx = state.selectedIdx[receiver];
                    if (idx === null || !digits[idx]) return;
                    let freqArr = digits.map(d => parseInt(d.textContent));
                    let carry = e.deltaY < 0 ? 1 : -1;
                    let i = idx;
                    while (carry !== 0 && i >= 0 && i < freqArr.length) {
                        let newVal = freqArr[i] + carry;
                        if (newVal > 9) {
                            freqArr[i] = 0;
                            carry = 1;
                            i--;
                        } else if (newVal < 0) {
                            freqArr[i] = 9;
                            carry = -1;
                            i--;
                        } else {
                            freqArr[i] = newVal;
                            carry = 0;
                        }
                    }
                    let newFreq = parseInt(freqArr.join(''));
                    newFreq = Math.max(30000, Math.min(70000000, newFreq));
                    state.localFreq[receiver] = newFreq;
                    updateFrequencyDisplay(receiver, newFreq);
                    let newDigits = Array.from(display.querySelectorAll('.digit')).filter(d => d.textContent !== '.' );
                    newDigits.forEach(d => d.classList.remove('selected'));
                    if (state.selectedIdx[receiver] !== null && newDigits[state.selectedIdx[receiver]]) {
                        newDigits[state.selectedIdx[receiver]].classList.add('selected');
                    }
                    clearTimeout(display._debounceTimer);
                    display._debounceTimer = setTimeout(() => {
                        setFrequency(receiver, newFreq);
                        state.lastSentFreq[receiver] = newFreq;
                        state.localFreq[receiver] = null;
                    }, 600);
                    e.preventDefault();
                }, { passive: false });

                document.addEventListener('click', function (e) {
                    if (!display.contains(e.target)) {
                        state.selectedIdx[receiver] = null;
                        state.editing[receiver] = false;
                        state.localFreq[receiver] = null;
                        updateFrequencyDisplay(receiver, state.lastBackendFreq[receiver]);
                    }
                });
            }

            async function setFrequency(receiver, freqHz) {
                try {
                    console.log(`Setting ${receiver} frequency to ${freqHz} Hz`);
                    const response = await fetch(`/api/cat/frequency/${receiver.toLowerCase()}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ frequencyHz: freqHz })
                    });
                    if (!response.ok) {
                        console.error('Failed to set frequency:', await response.text());
                    } else {
                        console.log(`Frequency set successfully: ${receiver} -> ${freqHz} Hz`);
                    }
                    updateFrequencyDisplay(receiver, freqHz);
                } catch (error) {
                    console.error('Error setting frequency:', error);
                }
            }

            async function setBand(receiver, band) {
                try {
                    console.log(`Setting ${receiver} band to ${band}`);
                    highlightButtons(receiver, band, state.lastMode[receiver], state.lastAntenna[receiver]);
                    state.lastBand[receiver] = band;
                    const response = await fetch(`/api/cat/band/${receiver.toLowerCase()}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ band })
                    });
                    if (!response.ok) {
                        console.error('Failed to set band:', await response.text());
                    } else {
                        console.log(`Band set successfully: ${receiver} -> ${band}`);
                    }
                } catch (error) {
                    console.error('Error setting band:', error);
                }
            }

            async function setMode(receiver, mode) {
                try {
                    console.log(`Setting ${receiver} mode to ${mode}`);
                    highlightButtons(receiver, state.lastBand[receiver], mode, state.lastAntenna[receiver]);
                    state.lastMode[receiver] = mode;
                    const response = await fetch(`/api/cat/mode/${receiver.toLowerCase()}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ mode })
                    });
                    if (!response.ok) {
                        console.error('Failed to set mode:', await response.text());
                    } else {
                        console.log(`Mode set successfully: ${receiver} -> ${mode}`);
                    }
                } catch (error) {
                    console.error('Error setting mode:', error);
                }
            }

            async function setAntenna(receiver, antenna) {
                pausePolling();
                try {
                    console.log(`Setting ${receiver} antenna to ${antenna}`);
                    highlightButtons(receiver, state.lastBand[receiver], state.lastMode[receiver], antenna);
                    state.lastAntenna[receiver] = antenna;
                    const response = await fetch(`/api/cat/antenna/${receiver.toLowerCase()}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ antenna })
                    });
                    if (!response.ok) {
                        console.error('Failed to set antenna:', await response.text());
                    } else {
                        console.log(`Antenna set successfully: ${receiver} -> ${antenna}`);
                    }
                } catch (error) {
                    console.error('Error setting antenna:', error);
                } finally {
                    resumePolling();
                }
            }

            function pausePolling() {
                if (state.pollingInterval && !state.operationInProgress) {
                    state.operationInProgress = true;
                    console.log('Polling paused for operation');
                }
            }

            function resumePolling() {
                if (state.operationInProgress) {
                    state.operationInProgress = false;
                    setTimeout(fetchRadioStatus, 500);
                    console.log('Polling resumed');
                }
            }

            async function fetchRadioStatus() {
                if (state.operationInProgress) {
                    console.log('Skipping poll - operation in progress');
                    return;
                }
                try {
                    const response = await fetch('/api/cat/status');
                    if (!response.ok) {
                        console.error('Failed to fetch status:', response.status);
                        return;
                    }
                    const data = await response.json();

                    if (data.maxPower !== undefined) {
                        state.maxPower = data.maxPower;
                        updatePowerSliderMax(data.maxPower);
                    }
                    if (data.radioModel !== undefined) {
                        state.radioModel = data.radioModel;
                    }

                    state.lastBackendFreq.A = data.vfoA.frequency;
                    state.lastBackendFreq.B = data.vfoB.frequency;
                    state.lastBand.A = data.vfoA.band;
                    state.lastBand.B = data.vfoB.band;
                    state.lastMode.A = data.vfoA.mode;
                    state.lastMode.B = data.vfoB.mode;
                    state.lastAntenna.A = data.vfoA.antenna;
                    state.lastAntenna.B = data.vfoB.antenna;

                    if (data.vfoA.power !== undefined) {
                        updatePowerSlider('A', data.vfoA.power);
                    }
                    if (data.vfoB.power !== undefined) {
                        updatePowerSlider('B', data.vfoB.power);
                    }

                    if (state.editing.A && state.lastSentFreq.A !== null && state.localFreq.A === null && data.vfoA.frequency === state.lastSentFreq.A) {
                        state.editing.A = false;
                        state.selectedIdx.A = null;
                    }
                    if (state.editing.B && state.lastSentFreq.B !== null && state.localFreq.B === null && data.vfoB.frequency === state.lastSentFreq.B) {
                        state.editing.B = false;
                        state.selectedIdx.B = null;
                    }

                    if (!state.editing.A) updateFrequencyDisplay('A', data.vfoA.frequency);
                    else updateFrequencyDisplay('A', state.localFreq.A);

                    if (!state.editing.B) updateFrequencyDisplay('B', data.vfoB.frequency);
                    else updateFrequencyDisplay('B', state.localFreq.B);

                    updateSMeter('A', data.vfoA.sMeter);
                    updateSMeter('B', data.vfoB.sMeter);
                    highlightButtons('A', data.vfoA.band, data.vfoA.mode, data.vfoA.antenna);
                    highlightButtons('B', data.vfoB.band, data.vfoB.mode, data.vfoB.antenna);
                } catch (error) {
                    console.error('Error fetching radio status:', error);
                }
            }

            // Power control functions
            function updatePowerDisplay(receiver, watts) {
                const display = document.getElementById('powerValue' + receiver);
                if (display) {
                    display.textContent = watts + 'W';
                }
            }

            async function setPower(receiver, watts) {
                try {
                    console.log(`Setting ${receiver} power to ${watts}W`);
                    state.lastPower[receiver] = parseInt(watts);
                    const response = await fetch(`/api/cat/power/${receiver.toLowerCase()}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ watts: parseInt(watts) })
                    });
                    if (!response.ok) {
    console.error('Failed to set power:', await response.text());
                    } else {
                        console.log(`Power set successfully: ${receiver} -> ${watts}W`);
                    }
                    updatePowerDisplay(receiver, watts);
                } catch (error) {
                    console.error('Error setting power:', error);
                }
            }

            function updatePowerSlider(receiver, watts) {
                if (state.editingPower && state.editingPower[receiver]) {
                    return; // Don't update while user is editing
                }
                const slider = document.getElementById('powerSlider' + receiver);
                if (slider) {
                    slider.value = watts;
                }
                updatePowerDisplay(receiver, watts);
            }

            function updatePowerSliderMax(maxPower) {
                const sliderA = document.getElementById('powerSliderA');
                const sliderB = document.getElementById('powerSliderB');
                const labelMaxA = document.getElementById('powerMaxLabelA');
                const labelMaxB = document.getElementById('powerMaxLabelB');

                if (sliderA) sliderA.max = maxPower;
                if (sliderB) sliderB.max = maxPower;
                if (labelMaxA) labelMaxA.textContent = maxPower + 'W';
                if (labelMaxB) labelMaxB.textContent = maxPower + 'W';
            }

            // S-Meter rendering (simplified for brevity)
            function sMeterLabel(val) {
                const points = [
                    { label: "S0", value: 0 },
                    { label: "S1", value: 4 },
                    { label: "S3", value: 30 },
                    { label: "S5", value: 65 },
                    { label: "S7", value: 95 },
                    { label: "S9", value: 130 },
                    { label: "S9+20", value: 171 },
                    { label: "S9+40", value: 212 },
                    { label: "S9+60", value: 255 }
                ];
                if (val <= points[0].value) return points[0].label;
                for (let i = 1; i < points.length; i++) {
                    if (val <= points[i].value) {
                        const prev = points[i - 1];
                        const next = points[i];
                        const frac = (val - prev.value) / (next.value - prev.value);
                        if (val === next.value) return next.label;
                        if (next.label.startsWith("S9+")) {
                            const plus = parseInt(next.label.replace("S9+", ""));
                            const prevPlus = prev.label.startsWith("S9+") ? parseInt(prev.label.replace("S9+", "")) : 0;
                            const interp = Math.round(prevPlus + frac * (plus - prevPlus));
                            return "S9+" + interp;
                        } else {
                            const prevNum = parseInt(prev.label.replace("S", ""));
                            const nextNum = parseInt(next.label.replace("S", ""));
                            const interp = Math.round(prevNum + frac * (nextNum - prevNum));
                            return "S" + interp;
                        }
                    }
                }
                return "S9+60";
            }

            function updateSMeter(receiver, value) {
                const valueSpan = document.getElementById('sMeterValue' + receiver);
                const rawSpan = document.getElementById('sMeterRaw' + receiver);

                if (valueSpan) valueSpan.textContent = sMeterLabel(value);
                if (rawSpan) rawSpan.textContent = `[${value}]`;

                if (receiver === 'A' && gaugeA) {
                    gaugeA.value = value;
                    gaugeA.draw();
                } else if (receiver === 'B' && gaugeB) {
                    gaugeB.value = value;
                    gaugeB.draw();
                }
            }

            // S-Meter Gauge Initialization
            function initializeGauges() {
                const gaugeWidth = 560;
                const gaugeHeight = 180;

                function createGaugeLabels(canvasId, labels) {
                    const canvas = document.getElementById(canvasId);
                    if (!canvas || canvas.nextElementSibling?.classList.contains('gauge-labels-overlay')) {
                        return;
                    }

                    const wrapper = document.createElement('div');
                    wrapper.className = 'gauge-wrapper';
                    wrapper.style.position = 'relative';
                    wrapper.style.display = 'inline-block';
                    wrapper.style.width = gaugeWidth + 'px';
                    wrapper.style.height = gaugeHeight + 'px';

                    const labelsDiv = document.createElement('div');
                    labelsDiv.className = 'gauge-labels-overlay';

                    const centerX = gaugeWidth / 2;
                    const centerY = gaugeHeight - 85;
                    const radius = gaugeWidth * 0.17;
                    const startAngle = 180;
                    const endAngle = 0;
                    const angleStep = (startAngle - endAngle) / (labels.length - 1);

                    labels.forEach((label, index) => {
                        const angle = startAngle - (angleStep * index);
                        const radians = (angle * Math.PI) / 180;
                        const x = centerX + radius * Math.cos(radians);
                        const y = centerY - radius * Math.sin(radians);

                        const span = document.createElement('span');
                        span.className = 'gauge-label';
                        span.textContent = label;
                        span.style.left = x + 'px';
                        span.style.top = y + 'px';
                        labelsDiv.appendChild(span);
                    });

                    canvas.parentNode.insertBefore(wrapper, canvas);
                    wrapper.appendChild(canvas);
                    wrapper.appendChild(labelsDiv);
                }

                gaugeA = new RadialGauge({
                    renderTo: 'sMeterCanvasA',
                    width: gaugeWidth,
                    height: gaugeHeight,
                    units: "",
                    minValue: 0,
                    maxValue: 255,
                    startAngle: 90,
                    ticksAngle: 180,
                    valueBox: false,
                    majorTicks: ["0", "4", "30", "65", "95", "130", "171", "212", "255"],
                    minorTicks: 0,
                    strokeTicks: false,
                    tickSide: "out",
                    needleSide: "center",
                    highlights: [
                        { from: 0, to: 130, color: "rgba(0,255,0,.25)" },
                        { from: 130, to: 255, color: "rgba(255,0,0,.25)" }
                    ],
                    colorPlate: "#ffffff",
                    borderShadowWidth: 0,
                    borders: false,
                    needleShadow: false,
                    colorMajorTicks: "#555555",
                    colorMinorTicks: "transparent",
                    colorNumbers: "transparent",
                    fontNumbersSize: 0,
                    colorBarProgress: "#198754",
                    colorBarProgressEnd: "#198754",
                    colorBar: "#dddddd",
                    barShadow: 0,
                    barWidth: 10,
                    barStrokeWidth: 0,
                    needleType: "arrow",
                    needleWidth: 3,
                    needleCircleSize: 7,
                    needleCircleOuter: false,
                    needleCircleInner: true,
                    colorNeedleCircleInner: "#dc3545",
                    colorNeedleCircleInnerEnd: "#dc3545",
                    animationDuration: 400,
                    animationRule: "linear",
                    value: 0
                });
                gaugeA.draw();

                const labels = ["0", "S1", "S3", "S5", "S7", "S9", "+20", "+40", "+60"];
                createGaugeLabels('sMeterCanvasA', labels);

                gaugeB = new RadialGauge({
                    renderTo: 'sMeterCanvasB',
                    width: gaugeWidth,
                    height: gaugeHeight,
                    units: "",
                    minValue: 0,
                    maxValue: 255,
                    startAngle: 90,
                    ticksAngle: 180,
                    valueBox: false,
                    majorTicks: ["0", "4", "30", "65", "95", "130", "171", "212", "255"],
                    minorTicks: 0,
                    strokeTicks: false,
                    tickSide: "out",
                    needleSide: "center",
                    highlights: [
                        { from: 0, to: 130, color: "rgba(0,255,0,.25)" },
                        { from: 130, to: 255, color: "rgba(255,0,0,.25)" }
                    ],
                    colorPlate: "#ffffff",
                    borderShadowWidth: 0,
                    borders: false,
                    needleShadow: false,
                    colorMajorTicks: "#555555",
                    colorMinorTicks: "transparent",
                    colorNumbers: "transparent",
                    fontNumbersSize: 0,
                    colorBarProgress: "#198754",
                    colorBarProgressEnd: "#198754",
                    colorBar: "#dddddd",
                    barShadow: 0,
                    barWidth: 10,
                    barStrokeWidth: 0,
                    needleType: "arrow",
                    needleWidth: 3,
                    needleCircleSize: 7,
                    needleCircleOuter: false,
                    needleCircleInner: true,
                    colorNeedleCircleInner: "#dc3545",
                    colorNeedleCircleInnerEnd: "#dc3545",
                    animationDuration: 400,
                    animationRule: "linear",
                    value: 0
                });
                gaugeB.draw();

                createGaugeLabels('sMeterCanvasB', labels);
            }

            // Call initialization
            initializeGauges();
            initializeDigitInteraction('A');
            initializeDigitInteraction('B');
            fetchRadioStatus();
            state.pollingInterval = setInterval(fetchRadioStatus, 500);

            window.radioControl = {
                setFrequency,
                setBand,
                setMode,
                setAntenna,
                updatePowerDisplay: (receiver, value) => {
                    state.editingPower[receiver] = true;
                    updatePowerDisplay(receiver, value);
                },
                setPower: async (receiver, value) => {
                    state.editingPower[receiver] = true;
                    setPower(receiver, value);
                    clearTimeout(state.editingPowerTimeout);
                    state.editingPowerTimeout = setTimeout(() => {
                        state.editingPower[receiver] = false;
                        updatePowerDisplay(receiver, state.lastPower[receiver]);
                    }, 1000);
                }
            };
        })();

        // SignalR integration for live updates
       

        connection.on("RadioStateUpdate", function (update) {
            if (update.property && update.value !== undefined) {
                if (update.property === "FrequencyA") {
                    updateFrequencyDisplay('A', update.value);
                }
                if (update.property === "FrequencyB") {
                    updateFrequencyDisplay('B', update.value);
                }
                // Add more property handlers as needed
            }
        });

        connection.start().catch(function (err) {
            return console.error(err.toString());
        });

        async function pollInitStatus() {
            try {
                const response = await fetch('/api/status/init');
                if (!response.ok) return;
                const data = await response.json();
                const overlay = document.getElementById('initOverlay');
                const statusText = document.getElementById('initStatusText');
                if (!overlay || !statusText) return;

                statusText.innerText = data.status;

                if (data.status === "complete") {
                    overlay.style.display = "none";
                } else if (data.status === "error") {
                    statusText.innerText = "Radio initialization failed. Please check connection and restart.";
                    overlay.style.display = "block";
                } else {
                    overlay.style.display = "block";
                }

                if (data.status !== "complete") {
                    setTimeout(pollInitStatus, 1000); // poll again in 1s
                }
            } catch (error) {
                console.error('Error polling init status:', error);
                setTimeout(pollInitStatus, 2000);
            }
        }

        pollInitStatus();
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                var aControls = document.getElementById('freqA-controls');
                var bControls = document.getElementById('freqB-controls');
                if (aControls) aControls.style.display = '';
                if (bControls) bControls.style.display = '';
            }
        });
    </script>
}